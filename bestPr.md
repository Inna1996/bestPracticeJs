## **Стрелочные функции**
>Одной из самых заметных новшеств современного JavaScript стало появление стрелочных функций (arrow function)
Стрелочные функции имеют упрощённый синтаксис
```
func = () => console.log('Привет');

//Тоже самое что

const func = function() {
    return console.log('Hello');
}
```
**У стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.**
```
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],
  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};
group.showList();
```
>Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.
Стрелочные функции лучше всего подходят когда требуется от this привязка к контексту, а не к самой функции.


## **Расположение скриптов**
>Переместите скрипты вниз страницы.
```
<p>And now you know my favorite kinds of corn. </p>  
<script type="text/javascript" src="path/to/file.js"></script>  
<script type="text/javascript" src="path/to/anotherFile.js"></script>  
</body>  
</html>
```

## **Переменные**
>Cледует всегда использовать **let/const** при объявлении переменной, иначе она попадает в глобальный контекст. Кроме того, использование let/const делает код более удобным для чтения.
```
//good

let userName = new userName();

//bad

userName = new userName()
```

## **Отступы**
>Существует два типа отступов:
- **Горизонтальные отступы: два или четыре пробела.**

  >Горизонтальный отступ выполняется с помощью 2 или 4 пробелов, или символа табуляции (клавиша Tab). Какой из них выбрать – это уже на ваше усмотрение. Пробелы больше распространены. Одно из преимуществ пробелов над табуляцией заключается в том, что пробелы допускают более гибкие конфигурации отступов, чем символ табуляции.

- **Вертикальные отступы: пустые строки для разбивки кода на «логические блоки».**

  >Даже одну функцию часто можно разделить на логические блоки. В примере ниже разделены инициализация переменных, основной цикл и возвращаемый результат:
```
     function pow(x, n) {
      let result = 1;
      //              <--
      for (let i = 0; i < n; i++) {
      result * = x;
      }
      //              <--
      return result;
    }
```

## **Пробелы**
>Используйте пробелы между параметрами и не используйте между именем функции и скобкой;
```
// bad
function edit (name,age) {
// тело функции
}

// good
function edit(name, age) {
// тело функции
}
```

## **Точка с запятой — ОБЯЗАТЕЛЬНА**
```
>Каждая инструкция должна заканчиваться точкой с запятой. Использование автоматической вставки точки с запятой запрещено.

// bad
let luke = {}
let leia = {}
[luke, leia].forEach(jedi => jedi.father = 'vader')

// good
let luke = {};
let leia = {};
[luke, leia].forEach((jedi) => {
jedi.father = 'vader';
});
```

## **Всегда заканчивайте выражение switch оператором default**
>Всегда заканчивайте выражение switch оператором default. Даже если вы думаете, что он совсем не нужен.
```
 switch (new Date().getDay()) {
     case 0:
         day = "Воскресенье";
         break;
     case 1:
         day = "Понедельник";
         break;
     case 2:
         day = "Вторник";
         break;
     case 3:
         day = "Среда";
         break;
     case 4:
         day = "Четверг";
         break;
     case 5:
         day = "Пятница";
         break;
     case 6:
         day = "Суббота";
         break;
     default:
        day = "Неизвестно";
}
```

## **Не используйте команду new Object()**
>Используйте { } вместо new Object()
Используйте "" вместо new String()
Используйте 0 вместо new Number()
Используйте false вместо new Boolean()
Используйте [ ] вместо new Array()
Используйте /()/ вместо new RegExp()
Используйте function (){ } вместо new Function()
```
 var x1 = {};           // новый объект
 var x2 = "";           // новая строка
 var x3 = 0;            // новое число
 var x4 = false;        // новое значение boolean
 var x5 = [];           // новый объект массива
 var x6 = /()/;         // новое регулярное выражение
 var x7 = function(){}; // новый объект функции   
```

## **Не объявляйте числовые, строковые или логические объекты**
>Всегда считайте числа, строки или логические значения примитивными значениями.
Объявление этих типов в качестве объектов замедляет скорость выполнения и производит неприятные побочные эффекты.
```
const x = 'Olga';             
const y = new String('Olga');
(x === y) // false, потому что x - строка, а y - объект.   
```

## **Используйте оператор строгого сравнения**
>Оператор == (нестрогое сравнение) всегда преобразует в соответствующие типы, прежде чем сравнить, поэтому вас могут возникнуть проблемы, если значения имеют различный тип данных, так как в этих случаях они попробуют преобразовать тип значений, что часто приводит к ошибкам.  
```
// нестрогое сравнение
0 == "";        // true
1 == "1";       // true
1 == true;      // true
// строгое сравнение
0 === "";       // false
1 === "1";      // false
1 === true;     // false
```
